--- Файл: config.json ---

{
    "language": "ru",
    "auto_organize": true,
    "run_initial_organization": true,
    "boxes": [
        {
            "name": "Документы"
        },
        {
            "name": "Изображения"
        },
        {
            "name": "Архивы"
        },
        {
            "name": "Другое"
        }
    ],
    "rules": [
        {
            "name": "Рабочие отчеты DOCX",
            "target_box": "Документы",
            "conditions": [
                {
                    "field": "extension",
                    "operator": "is",
                    "value": ".docx"
                },
                {
                    "field": "name",
                    "operator": "contains",
                    "value": "отчет"
                }
            ],
            "enabled": true
        },
        {
            "name": "Все PDF",
            "target_box": "Документы",
            "conditions": [
                {
                    "field": "extension",
                    "operator": "is",
                    "value": ".pdf"
                }
            ],
            "enabled": true
        },
        {
            "name": "Скриншоты",
            "target_box": "Изображения",
            "conditions": [
                {
                    "field": "extension",
                    "operator": "is",
                    "value": ".png"
                },
                {
                    "field": "name",
                    "operator": "starts_with",
                    "value": "screenshot"
                }
            ],
            "enabled": true
        },
        {
            "name": "Все JPG",
            "target_box": "Изображения",
            "conditions": [
                {
                    "field": "extension",
                    "operator": "is",
                    "value": ".jpg"
                }
            ],
            "enabled": true
        },
        {
            "name": "Архивы",
            "target_box": "Архивы",
            "conditions": [
                {
                    "field": "extension",
                    "operator": "in",
                    "value": ".zip,.rar,.7z"
                }
            ],
            "enabled": true
        }
    ],
    "exceptions": [],
    "theme": "dark"
}

--- Файл: core/__init__.py ---



--- Файл: core/analyzer.py ---

# core/analyzer.py
import logging
from pathlib import Path
from collections import defaultdict
from PyQt5.QtCore import QObject, pyqtSignal
from .utils import get_all_desktop_paths

class DesktopAnalyzer(QObject):
    suggestion_found = pyqtSignal(str, list) # (anomaly_type, extensions)

    def __init__(self, config):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.desktop_paths = get_all_desktop_paths()
        self.update_config(config) # Используем метод для начальной установки

    # --- НАЧАЛО ИЗМЕНЕНИЯ: ДОБАВЛЕН НЕДОСТАЮЩИЙ МЕТОД ---
    def update_config(self, config):
        """
        Обновляет конфигурацию, используемую анализатором.
        Это нужно, чтобы анализатор знал о новых категориях, созданных пользователем.
        """
        self.config = config
    # --- КОНЕЦ ИЗМЕНЕНИЯ ---

    def analyze_desktop(self):
        """Анализирует рабочий стол на предмет аномалий."""
        if not self.desktop_paths:
            self.logger.warning("Рабочий стол для анализа не найден.")
            return

        desktop_path = Path(self.desktop_paths[0]) # Анализируем основной рабочий стол
        try:
            self._find_unclassified_extensions(desktop_path)
        except Exception as e:
            self.logger.error(f"Ошибка при анализе рабочего стола: {e}", exc_info=True)

    def _find_unclassified_extensions(self, desktop_path: Path):
        """Ищет расширения, для которых нет категорий."""
        known_extensions = set()
        # Берем актуальный список категорий из self.config
        for exts in self.config.get('categories', {}).values():
            known_extensions.update(exts)

        extension_counts = defaultdict(int)
        for entry in desktop_path.iterdir():
            if entry.is_file():
                ext = entry.suffix.lower()
                if ext and ext not in known_extensions:
                    extension_counts[ext] += 1

        # Ищем аномалии: > 10 файлов с одним неклассифицированным расширением
        anomalies = [ext for ext, count in extension_counts.items() if count > 10]

        if anomalies:
            self.logger.info(f"Найдена аномалия: неклассифицированные расширения {anomalies}")
            self.suggestion_found.emit("unclassified_extensions", anomalies)
        else:
            self.logger.info("Анализ завершен, аномалий не найдено.")

--- Файл: core/box_widget.py ---

# core/box_widget.py
import logging
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QLabel, QListWidget, QListView, QSizeGrip
from PyQt5.QtCore import Qt, QPoint, pyqtSignal
from PyQt5.QtGui import QFont

class BoxWidget(QWidget):
    widget_moved = pyqtSignal(str, QPoint)
    widget_resized = pyqtSignal(str, object)

    def __init__(self, category_name, parent=None):
        super().__init__(parent)
        self.category_name = category_name
        self.logger = logging.getLogger(__name__)
        self.old_pos = self.pos()

        # --- НАСТРОЙКА ОКНА ---
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnBottomHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setStyleSheet("""
            QWidget {
                background-color: rgba(45, 45, 45, 0.85);
                border-radius: 8px;
                color: white;
            }
        """)

        # --- МАКЕТ ---
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(1, 1, 1, 1)

        # --- ЗАГОЛОВОК ---
        self.header = QLabel(self.category_name)
        self.header.setFont(QFont("Segoe UI", 10, QFont.Bold))
        self.header.setAlignment(Qt.AlignCenter)
        self.header.setStyleSheet("background-color: rgba(60, 60, 60, 0.9); border-top-left-radius: 8px; border-top-right-radius: 8px; padding: 5px;")
        self.layout.addWidget(self.header)

        # --- СПИСОК ФАЙЛОВ ---
        self.file_list = QListWidget()
        self.file_list.setViewMode(QListView.IconMode)
        self.file_list.setMovement(QListView.Static)
        self.file_list.setResizeMode(QListView.Adjust)
        self.file_list.setWordWrap(True)
        self.file_list.setStyleSheet("QListWidget { border: none; }")
        self.layout.addWidget(self.file_list)

        # --- ИЗМЕНЕНИЕ РАЗМЕРА ---
        size_grip = QSizeGrip(self)
        self.layout.addWidget(size_grip, 0, Qt.AlignBottom | Qt.AlignRight)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and self.header.geometry().contains(event.pos()):
            self.old_pos = event.globalPos()

    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton and self.header.geometry().contains(event.pos()):
            delta = QPoint(event.globalPos() - self.old_pos)
            self.move(self.x() + delta.x(), self.y() + delta.y())
            self.old_pos = event.globalPos()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.widget_moved.emit(self.category_name, self.pos())

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.widget_resized.emit(self.category_name, self.size())

    def add_item(self, file_name, file_path):
        # TODO: Добавить реальные иконки файлов
        item = self.file_list.addItem(file_name)
        # item.setData(Qt.UserRole, file_path) # Сохраняем путь для будущего использования

    def filter_items(self, query):
        for i in range(self.file_list.count()):
            item = self.file_list.item(i)
            is_visible = query.lower() in item.text().lower()
            item.setHidden(not is_visible)

--- Файл: core/classifier.py ---

# core/classifier.py
import logging
from pathlib import Path
from datetime import datetime

class FileClassifier:
    def __init__(self, config):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.update_config(config)

    def update_config(self, config):
        self.rules = config.get("rules", [])
        self.exceptions = config.get("exceptions", [])
        self.logger.info("Конфигурация классификатора обновлена.")

    def classify_file(self, file_path: Path) -> str:
        """
        Определяет целевую "коробку" для файла на основе набора правил.
        Возвращает имя "коробки" или None, если правило не найдено.
        """
        if not file_path.exists() or file_path.is_dir():
            return None

        if file_path.name in self.exceptions:
            self.logger.info(f"Файл '{file_path.name}' находится в исключениях, пропущен.")
            return None

        for rule in self.rules:
            if rule.get("enabled", False) and self._check_conditions(file_path, rule.get("conditions", [])):
                target_box = rule.get("target_box")
                self.logger.info(f"Файл '{file_path.name}' соответствует правилу '{rule.get('name')}'. Цель: '{target_box}'.")
                return target_box

        self.logger.info(f"Для файла '{file_path.name}' не найдено подходящих правил. Цель: 'Другое'.")
        return "Другое" # Категория по умолчанию

    def _check_conditions(self, file_path: Path, conditions: list) -> bool:
        """Проверяет, соответствует ли файл всем условиям правила."""
        if not conditions:
            return False

        for cond in conditions:
            field = cond.get("field")
            operator = cond.get("operator")
            value = cond.get("value")

            # Получаем фактическое значение поля из файла
            file_value = self._get_file_field_value(file_path, field)
            if file_value is None:
                return False # Если не удалось получить значение, условие не выполнено

            # Проверяем условие
            if not self._evaluate_operator(file_value, operator, value):
                return False # Если хотя бы одно условие неверно, все правило неверно

        return True # Все условия выполнены

    def _get_file_field_value(self, file_path: Path, field: str):
        """Возвращает значение указанного поля для файла."""
        if field == "extension":
            return file_path.suffix.lower()
        if field == "name":
            return file_path.stem.lower()
        if field == "full_name":
            return file_path.name.lower()
        if field == "date_created":
            return datetime.fromtimestamp(file_path.stat().st_ctime)
        # Добавьте другие поля по необходимости (date_modified, size и т.д.)
        return None

    def _evaluate_operator(self, file_value, operator: str, rule_value) -> bool:
        """Сравнивает значение файла со значением из правила с помощью оператора."""
        rule_value_lower = str(rule_value).lower()
        file_value_str_lower = str(file_value).lower()

        if operator == "is":
            return file_value_str_lower == rule_value_lower
        if operator == "is_not":
            return file_value_str_lower != rule_value_lower
        if operator == "contains":
            return rule_value_lower in file_value_str_lower
        if operator == "not_contains":
            return rule_value_lower not in file_value_str_lower
        if operator == "starts_with":
            return file_value_str_lower.startswith(rule_value_lower)
        if operator == "ends_with":
            return file_value_str_lower.endswith(rule_value_lower)
        if operator == "in":
            # Для оператора 'in' значением является строка расширений через запятую
            extensions = [ext.strip().lower() for ext in rule_value.split(',')]
            return file_value_str_lower in extensions
        # Добавьте другие операторы (>, < для дат и размеров)
        return False

--- Файл: core/cleaner.py ---

# core/cleaner.py
import os
import logging
import shutil
from pathlib import Path
from PyQt5.QtCore import QObject, pyqtSignal
# ИСПРАВЛЕНИЕ: Абсолютный импорт
from core.security import FileRecycleBin


class DesktopCleaner(QObject):
    progress_updated = pyqtSignal(int)
    cleaning_completed = pyqtSignal(str)
    operation_logged = pyqtSignal(dict)  # Для системы отмены

    # --- НАЧАЛО ИЗМЕНЕНИЯ ---
    def __init__(self, config):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.recycle_bin = FileRecycleBin()
        self.update_config(config)  # Используем метод для начальной установки конфига

    def update_config(self, config):
        """Обновляет конфигурацию для применения настроек 'на лету'."""
        self.config = config

    # --- КОНЕЦ ИЗМЕНЕНИЯ ---

    # --- ИЗМЕНЕНИЕ: Метод больше не принимает 'options', а берет их из self.config ---
    def clean_desktop(self, desktop_path: str):
        """
        Очищает рабочий стол на основе настроек из конфигурации.
        """
        try:
            # Получаем настройки очистки напрямую из сохраненного конфига
            options = self.config.get("clean_options", {})

            desktop = Path(desktop_path)
            if not desktop.exists():
                raise FileNotFoundError(f"Путь к рабочему столу не найден: {desktop_path}")

            entries = list(desktop.iterdir())
            total_files = len(entries)
            removed_count = 0
            operation_details = {
                'type': 'clean',
                'removed_files': []
            }

            for i, entry in enumerate(entries):
                if entry.is_file():
                    # Передаем 'options' во внутренний метод
                    if self._should_remove(entry, options):
                        try:
                            original_path = str(entry)
                            backup_path = self.recycle_bin.safe_delete(original_path)

                            operation_details['removed_files'].append({
                                'original': original_path,
                                'backup': backup_path
                            })
                            removed_count += 1
                        except Exception as e:
                            self.logger.warning(f"Не удалось удалить {entry.name}: {e}")

                self.progress_updated.emit((i + 1) * 100 // total_files if total_files > 0 else 100)

            msg = f"Очистка завершена. Удалено элементов: {removed_count}."
            self.cleaning_completed.emit(msg)
            self.operation_logged.emit(operation_details)
        except Exception as e:
            self.logger.error(f"Критическая ошибка при очистке рабочего стола {desktop_path}: {e}", exc_info=True)
            self.cleaning_completed.emit(f"Ошибка очистки: {e}")

    def _should_remove(self, file_entry: Path, options: dict) -> bool:
        """Определяет, следует ли удалять файл."""
        ext = file_entry.suffix.lower()

        if options.get("remove_broken_shortcuts") and ext == ".lnk":
            try:
                import win32com.client
                shell = win32com.client.Dispatch("WScript.Shell")
                shortcut = shell.CreateShortCut(str(file_entry))
                return not Path(shortcut.Targetpath).exists()
            except ImportError:
                self.logger.warning("Модуль win32com не найден. Проверка битых ярлыков отключена.")
                return False
            except Exception:
                return True

        if options.get("remove_temp_files") and (file_entry.name.startswith("~$") or file_entry.name.startswith("~")):
            return True

        if options.get("remove_by_ext") and ext in [".tmp", ".bak", ".old"]:
            return True

        return False

--- Файл: core/duplicates.py ---

# core/duplicates.py
import os
import hashlib
import logging
from collections import defaultdict
from pathlib import Path
from PyQt5.QtCore import QObject, pyqtSignal


class DuplicateFinder(QObject):
    # --- ДОБАВЛЕН НОВЫЙ СИГНАЛ ---
    status_updated = pyqtSignal(str)
    duplicates_found = pyqtSignal(dict)
    progress_updated = pyqtSignal(int)

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)

    def find_duplicates(self, folder_path: str) -> None:
        try:
            duplicates = defaultdict(list)
            files_by_size = defaultdict(list)
            start_path = Path(folder_path)

            if not start_path.is_dir():
                self.logger.error(f"Путь для поиска дубликатов не является директорией: {folder_path}")
                self.duplicates_found.emit({})
                return

            all_files = [p for p in start_path.rglob('*') if p.is_file()]
            total_files = len(all_files)
            if total_files == 0:
                self.duplicates_found.emit({})
                return

            # Этап 1: Группировка по размеру
            for i, filepath in enumerate(all_files):
                # --- ОТПРАВКА СИГНАЛА ---
                self.status_updated.emit(f"Анализ размера: {filepath.name}")
                try:
                    file_size = filepath.stat().st_size
                    files_by_size[file_size].append(filepath)
                except OSError as e:
                    self.logger.warning(f"Не удалось получить размер файла {filepath.name}: {e}")
                self.progress_updated.emit(int((i + 1) / total_files * 50))

            # Этап 2: Проверка хешей
            size_groups = [files for files in files_by_size.values() if len(files) > 1]
            total_groups = len(size_groups)
            if total_groups == 0:
                self.duplicates_found.emit({})
                return

            processed_files_in_groups = 0
            for group_idx, files in enumerate(size_groups):
                hashes = defaultdict(list)
                for filepath in files:
                    # --- ОТПРАВКА СИГНАЛА ---
                    self.status_updated.emit(f"Вычисление хеша: {filepath.name}")
                    try:
                        file_hash = self._calculate_hash(filepath)
                        if file_hash:
                            hashes[file_hash].append(str(filepath))
                    except OSError as e:
                        self.logger.warning(f"Не удалось вычислить хеш для {filepath.name}: {e}")

                for hash_value, hash_files in hashes.items():
                    if len(hash_files) > 1:
                        duplicates[hash_value] = hash_files

                self.progress_updated.emit(50 + int((group_idx + 1) / total_groups * 50))

            self.duplicates_found.emit(dict(duplicates))
        except Exception as e:
            self.logger.error(f"Ошибка при поиске дубликатов: {e}", exc_info=True)
            self.duplicates_found.emit({})

    def _calculate_hash(self, filepath: Path, block_size=65536) -> str:
        hasher = hashlib.md5()
        try:
            with open(filepath, 'rb') as f:
                buf = f.read(block_size)
                while len(buf) > 0:
                    hasher.update(buf)
                    buf = f.read(block_size)
            return hasher.hexdigest()
        except (IOError, OSError) as e:
            self.logger.warning(f"Не удалось прочитать файл для хеширования {filepath.name}: {e}")
            return None

--- Файл: core/organizer.py ---

# core/organizer.py
import os
import shutil
import logging
from pathlib import Path
from PyQt5.QtCore import QObject, pyqtSignal
from .classifier import FileClassifier
from .utils import get_all_desktop_paths

class DesktopOrganizer(QObject):
    status_updated = pyqtSignal(str)
    progress_updated = pyqtSignal(int)
    organization_completed = pyqtSignal(str)
    operation_logged = pyqtSignal(dict)
    # --- НОВЫЙ СИГНАЛ ДЛЯ ИНТЕГРАЦИИ С BoxManager ---
    file_classified_for_box = pyqtSignal(str, str) # (category, file_path)

    def __init__(self, config):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.desktop_paths = get_all_desktop_paths()
        # --- ИЗМЕНЕНИЕ: Инициализация нового классификатора ---
        self.classifier = FileClassifier(config)
        self.update_config(config)
        # --- НОВОЕ: Путь к скрытому хранилищу ---
        if self.desktop_paths:
            self.storage_path = Path(self.desktop_paths[0]).parent / ".DesktopManagerStorage"
            self.storage_path.mkdir(exist_ok=True)
            self.logger.info(f"Хранилище файлов: {self.storage_path}")

    def update_config(self, config):
        self.config = config
        self.classifier.update_config(config)
        self.auto_organize = self.config.get('auto_organize_enabled', True)

    def organize_all_desktops(self):
        if not self.desktop_paths:
            self.organization_completed.emit("Рабочие столы для организации не найдены.")
            return
        for path_str in self.desktop_paths:
            self.organize_single_desktop(Path(path_str))

    def organize_single_desktop(self, desktop_path: Path):
        try:
            entries = [e for e in desktop_path.iterdir() if e.is_file()]
            total_items = len(entries)
            moved_count = 0
            operation_details = {'type': 'organize', 'moved_files': []}

            for i, entry in enumerate(entries):
                self.status_updated.emit(f"Проверка: {entry.name}")

                if entry.name.startswith(".") or entry.name == "desktop.ini":
                    continue

                # --- ИЗМЕНЕНИЕ: Используем новый классификатор ---
                target_box = self.classifier.classify_file(entry)
                if target_box:
                    moved_info = self._move_to_storage(entry, target_box)
                    if moved_info:
                        operation_details['moved_files'].append(moved_info)
                        moved_count += 1

                if total_items > 0:
                    self.progress_updated.emit(int((i + 1) / total_items * 100))

            msg = f"Организация завершена. Перемещено: {moved_count}."
            self.organization_completed.emit(msg)
            if moved_count > 0:
                self.operation_logged.emit(operation_details)
        except Exception as e:
            self.logger.error(f"Ошибка при организации {desktop_path}: {e}", exc_info=True)
            self.organization_completed.emit(f"Ошибка организации: {e}")

    def handle_new_file(self, file_path_str: str):
        if not self.auto_organize:
            return

        file_path = Path(file_path_str)
        target_box = self.classifier.classify_file(file_path)
        if target_box:
            # Убедимся, что файл находится на одном из отслеживаемых рабочих столов
            if any(file_path.parent == Path(p) for p in self.desktop_paths):
                 self._move_to_storage(file_path, target_box)

    def _move_to_storage(self, src_path: Path, target_box: str) -> dict:
        """Перемещает файл в центральное хранилище и сообщает UI."""
        if not self.storage_path:
            self.logger.error("Путь к хранилищу не определен.")
            return None

        dest_path = self.storage_path / src_path.name
        counter = 1
        while dest_path.exists():
            dest_path = self.storage_path / f"{src_path.stem}_{counter}{src_path.suffix}"
            counter += 1

        try:
            shutil.move(str(src_path), str(dest_path))
            self.logger.info(f"Файл перемещен в хранилище: '{src_path.name}' -> '{dest_path}'")
            # --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Отправляем сигнал для BoxManager ---
            self.file_classified_for_box.emit(target_box, str(dest_path))
            return {'original': str(src_path), 'new': str(dest_path)}
        except Exception as e:
            self.logger.error(f"Ошибка перемещения файла '{src_path.name}' в хранилище: {e}")
            return None

--- Файл: core/plugins/cloud_integration.py ---

#core/plugins/cloud_integration.py
import os
import logging
from abc import ABC, abstractmethod

from core.utils import get_desktop_path


class CloudPlugin(ABC):
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    @abstractmethod
    def sync_folder(self, folder_path):
        pass


class OneDrivePlugin(CloudPlugin):
    def sync_folder(self, folder_path):
        # Реализация синхронизации с OneDrive
        self.logger.info(f"Синхронизация {folder_path} с OneDrive (не реализовано).")
        pass


class GoogleDrivePlugin(CloudPlugin):
    def sync_folder(self, folder_path):
        # Реализация синхронизации с Google Drive
        self.logger.info(f"Синхронизация {folder_path} с Google Drive (не реализовано).")
        pass


class CloudManager:
    def __init__(self):
        self.plugins = {
            "onedrive": OneDrivePlugin(),
            "googledrive": GoogleDrivePlugin()
        }

    def sync_category(self, category_name, cloud_service):
        if cloud_service in self.plugins:
            folder_path = os.path.join(get_desktop_path(), category_name)
            self.plugins[cloud_service].sync_folder(folder_path)

--- Файл: core/profile_manager.py ---

# core/profile_manager.py
import os
import json
import logging
from pathlib import Path


class ProfileManager:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.PROFILES_DIR = Path("profiles")
        self.PROFILES_DIR.mkdir(exist_ok=True)
        self.current_profile = "default"

    def save_profile(self, name: str, settings: dict) -> bool:
        """Сохранение профиля настроек"""
        try:
            if not name.strip():
                self.logger.error("Имя профиля не может быть пустым.")
                return False
            profile_path = self.PROFILES_DIR / f"{name}.json"
            with open(profile_path, 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=4, ensure_ascii=False)
            self.logger.info(f"Профиль '{name}' успешно сохранен.")
            return True
        except Exception as e:
            self.logger.error(f"Ошибка сохранения профиля {name}: {e}")
            return False

    def load_profile(self, name: str) -> dict:
        """
        Загрузка профиля настроек.
        Исправлена ошибка при чтении пустого файла.
        """
        profile_path = self.PROFILES_DIR / f"{name}.json"
        if not profile_path.exists() or profile_path.stat().st_size == 0:
            self.logger.warning(f"Файл профиля '{name}' не найден или пуст.")
            return None

        try:
            with open(profile_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            self.logger.error(f"Ошибка декодирования JSON в профиле {name}: {e}")
            return None
        except Exception as e:
            self.logger.error(f"Не удалось загрузить профиль {name}: {e}")
            return None

    def list_profiles(self) -> list:
        """Получение списка доступных профилей"""
        return [p.stem for p in self.PROFILES_DIR.glob("*.json")]

    def delete_profile(self, name: str) -> bool:
        """Удаление файла профиля."""
        try:
            profile_path = self.PROFILES_DIR / f"{name}.json"
            if profile_path.exists():
                profile_path.unlink()
                self.logger.info(f"Профиль '{name}' удален.")
                return True
            else:
                self.logger.warning(f"Профиль '{name}' для удаления не найден.")
                return False
        except Exception as e:
            self.logger.error(f"Ошибка при удалении профиля '{name}': {e}")
            return False

--- Файл: core/scheduler.py ---

#core/scheduler.py
import logging
from datetime import datetime, timedelta
from apscheduler.schedulers.background import BackgroundScheduler

class AutoOptimizer:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.scheduler = BackgroundScheduler(daemon=True)
        try:
            self.scheduler.start()
            self.logger.info("Планировщик задач запущен")
        except Exception as e:
            self.logger.error(f"Не удалось запустить планировщик: {e}")

    def schedule_task(self, task_fn, interval_hours=24):
        """Планирование регулярной задачи"""
        try:
            self.scheduler.add_job(
                task_fn,
                'interval',
                hours=interval_hours,
                next_run_time=datetime.now() + timedelta(seconds=10) # Небольшая задержка перед первым запуском
            )
            self.logger.info(f"Задача '{task_fn.__name__}' запланирована с интервалом {interval_hours} ч.")
        except Exception as e:
            self.logger.error(f"Ошибка планирования задачи: {e}")

    def shutdown(self):
        """Корректное завершение работы планировщика."""
        if self.scheduler.running:
            self.scheduler.shutdown()
            self.logger.info("Планировщик задач остановлен.")

--- Файл: core/security.py ---

#core/security.py
import os
import shutil
import logging
from datetime import datetime
from pathlib import Path


class FileRecycleBin:
    def __init__(self, bin_dir="recycle_bin"):
        self.logger = logging.getLogger(__name__)
        self.bin_dir = Path(bin_dir)
        self.bin_dir.mkdir(exist_ok=True)
        self.logger.info(f"Корзина приложения инициализирована в: {self.bin_dir.resolve()}")

    def safe_delete(self, file_path_str: str) -> str:
        """Безопасное удаление с перемещением в корзину приложения."""
        try:
            file_path = Path(file_path_str)
            if not file_path.exists():
                raise FileNotFoundError(f"Файл для удаления не найден: {file_path}")

            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
            dest = self.bin_dir / f"{timestamp}_{file_path.name}"

            shutil.move(str(file_path), str(dest))
            self.logger.info(f"Файл '{file_path.name}' перемещен в корзину приложения.")
            return str(dest)
        except Exception as e:
            self.logger.error(f"Ошибка безопасного удаления файла {file_path_str}: {e}")
            raise

    def restore_file(self, backup_path_str: str, original_path_str: str) -> str:
        """Восстановление файла из корзины по оригинальному пути."""
        try:
            backup_path = Path(backup_path_str)
            if not backup_path.exists():
                raise FileNotFoundError(f"Резервная копия не найдена: {backup_path}")

            dest_path = Path(original_path_str)
            # Создаем родительские директории, если их нет
            dest_path.parent.mkdir(parents=True, exist_ok=True)

            shutil.move(str(backup_path), str(dest_path))
            self.logger.info(f"Файл '{backup_path.name}' восстановлен в '{dest_path}'.")
            return str(dest_path)
        except Exception as e:
            self.logger.error(f"Ошибка восстановления файла {backup_path_str}: {e}")
            raise

--- Файл: core/sorter.py ---

# core/sorter.py:
import os
import shutil
import logging
from pathlib import Path
from datetime import datetime
from PyQt5.QtCore import QObject, pyqtSignal


class FileSorter(QObject):
    progress_updated = pyqtSignal(int)
    sorting_completed = pyqtSignal(str)
    operation_logged = pyqtSignal(dict)  # Для системы отмены

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)

    def sort_desktop(self, desktop_path: str, criteria: dict):
        """
        Сортирует файлы на рабочем столе.
        Принимает путь к рабочему столу как аргумент.
        """
        try:
            desktop = Path(desktop_path)
            if not desktop.is_dir():
                raise FileNotFoundError(f"Директория рабочего стола не найдена: {desktop_path}")

            entries = [e for e in desktop.iterdir() if e.is_file()]
            total_files = len(entries)
            if total_files == 0:
                self.sorting_completed.emit("Сортировка завершена: файлы не найдены.")
                return

            operation_details = {
                'type': 'sort',
                'moved_files': []
            }

            for i, entry in enumerate(entries):
                moved_info = self._sort_file(entry, desktop, criteria)
                if moved_info:
                    operation_details['moved_files'].append(moved_info)
                self.progress_updated.emit(int((i + 1) / total_files * 100))

            self.sorting_completed.emit("Сортировка успешно завершена.")
            if operation_details['moved_files']:
                self.operation_logged.emit(operation_details)

        except Exception as e:
            self.logger.error(f"Ошибка при сортировке: {e}", exc_info=True)
            self.sorting_completed.emit(f"Ошибка сортировки: {e}")

    def _sort_file(self, file_path: Path, desktop_path: Path, criteria: dict) -> dict:
        """Сортирует один файл и возвращает информацию для отмены."""
        target_dir = None
        original_path_str = str(file_path)

        try:
            if criteria.get("by_type"):
                ext = file_path.suffix[1:].lower() if file_path.suffix else "NoExtension"
                target_dir = desktop_path / ext
            elif criteria.get("by_date"):
                mod_time = datetime.fromtimestamp(file_path.stat().st_mtime)
                month_year = mod_time.strftime("%Y-%m")
                target_dir = desktop_path / month_year
            elif criteria.get("by_size"):
                size = file_path.stat().st_size
                if size < 1024 * 1024:
                    size_group = "Маленькие"
                elif size < 10 * 1024 * 1024:
                    size_group = "Средние"
                else:
                    size_group = "Большие"
                target_dir = desktop_path / size_group

            if target_dir:
                target_dir.mkdir(exist_ok=True)
                dest_path = target_dir / file_path.name
                shutil.move(original_path_str, str(dest_path))
                return {'original': original_path_str, 'new': str(dest_path)}

        except Exception as e:
            self.logger.warning(f"Не удалось отсортировать файл {file_path.name}: {e}")

        return None

--- Файл: core/startup_manager.py ---

# core/startup_manager.py
import winreg
import sys
import os
import logging

# --- ИЗМЕНЕНИЕ: Получаем именованный логгер ---
logger = logging.getLogger(__name__)

APP_NAME = "DesktopManager"
REG_PATH = r"Software\Microsoft\Windows\CurrentVersion\Run"

def get_run_command():
    python_exe = sys.executable
    script_path = os.path.abspath(sys.argv[0])
    return f'"{python_exe}" "{script_path}"'

def is_enabled():
    try:
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, winreg.KEY_READ)
        winreg.QueryValueEx(key, APP_NAME)
        winreg.CloseKey(key)
        return True
    except FileNotFoundError:
        return False
    except Exception as e:
        # --- ИЗМЕНЕНИЕ: Используем logger ---
        logger.error(f"Ошибка при проверке статуса автозапуска: {e}")
        return False

def enable():
    try:
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, winreg.KEY_WRITE)
        command = get_run_command()
        winreg.SetValueEx(key, APP_NAME, 0, winreg.REG_SZ, command)
        winreg.CloseKey(key)
        # --- ИЗМЕНЕНИЕ: Используем logger ---
        logger.info(f"Автозапуск включен. Команда: {command}")
        return True
    except Exception as e:
        logger.error(f"Не удалось включить автозапуск: {e}")
        return False

def disable():
    try:
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, winreg.KEY_WRITE)
        winreg.DeleteValue(key, APP_NAME)
        winreg.CloseKey(key)
        # --- ИЗМЕНЕНИЕ: Используем logger ---
        logger.info("Автозапуск отключен.")
        return True
    except FileNotFoundError:
        return True
    except Exception as e:
        logger.error(f"Не удалось отключить автозапуск: {e}")
        return False

--- Файл: core/threading_pool.py ---

#core/threading_pool
from PyQt5.QtCore import QRunnable, QThreadPool, QObject, pyqtSignal
import logging

logger = logging.getLogger(__name__)

class WorkerSignals(QObject):
    """Сигналы для рабочего потока"""
    error = pyqtSignal(tuple)
    finished = pyqtSignal()

class FileTask(QRunnable):
    def __init__(self, task_fn, *args, **kwargs):
        super().__init__()
        self.task_fn = task_fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

    def run(self):
        try:
            self.task_fn(*self.args, **self.kwargs)
        except Exception as e:
            logger.error(f"Ошибка в фоновой задаче '{self.task_fn.__name__}': {e}", exc_info=True)
            # self.signals.error.emit((type(e), e, traceback.format_exc())) # Для более детальной отладки
        finally:
            self.signals.finished.emit()


class ThreadManager:
    def __init__(self, max_threads=4):
        self.thread_pool = QThreadPool.globalInstance()
        self.thread_pool.setMaxThreadCount(max_threads)
        logger.info(f"Пул потоков инициализирован (макс. потоков: {max_threads})")

    def start_task(self, task_fn, *args, **kwargs):
        task = FileTask(task_fn, *args, **kwargs)
        self.thread_pool.start(task)
        logger.info(f"Задача '{task_fn.__name__}' добавлена в пул потоков.")

--- Файл: core/undo_manager.py ---

# core/undo_manager.py
import logging
import json
import shutil
from datetime import datetime
from pathlib import Path

from PyQt5.QtCore import pyqtSignal


class UndoManager:
    file_restored_to_desktop = pyqtSignal(str, str)  # (category, file_path)
    def __init__(self, max_history=10):
        self.logger = logging.getLogger(__name__)
        self.history_stack = []
        self.max_history = max_history
        self.UNDO_DIR = Path("undo_history")
        self.UNDO_DIR.mkdir(exist_ok=True)
        self.logger.info("Менеджер отмены инициализирован.")

    def add_operation(self, operation_data: dict) -> None:
        """Добавление операции в историю."""
        try:
            operation_type = operation_data.get('type', 'unknown')
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
            filename = f"{timestamp}_{operation_type}.json"
            filepath = self.UNDO_DIR / filename

            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(operation_data, f, indent=4, ensure_ascii=False)

            self.history_stack.append({
                'type': operation_type,
                'file': str(filepath),
                'timestamp': timestamp
            })
            self.logger.info(f"Операция '{operation_type}' добавлена в историю отмены.")

            # Ограничиваем размер истории
            if len(self.history_stack) > self.max_history:
                oldest = self.history_stack.pop(0)
                try:
                    Path(oldest['file']).unlink()
                except OSError as e:
                    self.logger.warning(f"Не удалось удалить старый файл истории: {e}")

        except Exception as e:
            self.logger.error(f"Ошибка добавления операции в историю: {e}", exc_info=True)

    def undo_last(self) -> (bool, str):
        """Отмена последней операции. Возвращает кортеж (успех, сообщение)."""
        if not self.history_stack:
            self.logger.warning("История операций пуста, отмена невозможна.")
            return False, "История операций пуста."

        last_op = self.history_stack.pop()
        op_type = last_op['type']
        op_file = Path(last_op['file'])

        try:
            with open(op_file, 'r', encoding='utf-8') as f:
                operation_data = json.load(f)

            if op_type == 'clean':
                self._undo_clean(operation_data)
            elif op_type in ['organize', 'sort']:
                self._undo_move(operation_data)
            else:
                raise NotImplementedError(f"Отмена для операции типа '{op_type}' не реализована.")

            op_file.unlink()  # Удаляем файл истории после успешной отмены
            msg = f"Операция '{op_type}' успешно отменена."
            self.logger.info(msg)
            return True, msg
        except Exception as e:
            self.logger.error(f"Ошибка отмены операции '{op_type}': {e}", exc_info=True)
            # Возвращаем операцию в стек, если отмена не удалась
            self.history_stack.append(last_op)
            return False, f"Ошибка отмены: {e}"

    def _undo_clean(self, operation_data: dict):
        """Отмена операции очистки (восстановление из корзины приложения)."""
        # ИСПРАВЛЕНИЕ: Абсолютный импорт
        from core.security import FileRecycleBin
        recycle_bin = FileRecycleBin()
        restored_count = 0
        for file_info in reversed(operation_data.get('removed_files', [])):
            try:
                recycle_bin.restore_file(file_info['backup'], file_info['original'])
                restored_count += 1
            except Exception as e:
                self.logger.warning(f"Не удалось восстановить файл {file_info['original']}: {e}")
        self.logger.info(f"Восстановлено {restored_count} файлов после очистки.")

    def _undo_move(self, operation_data: dict):
        """Отмена операций организации или сортировки (перемещение обратно)."""
        moved_count = 0
        for file_info in reversed(operation_data.get('moved_files', [])):
            try:
                src = Path(file_info['new'])      # Путь в хранилище
                dest = Path(file_info['original']) # Путь на рабочем столе

                if src.exists():
                    dest.parent.mkdir(exist_ok=True, parents=True)
                    shutil.move(str(src), str(dest))
                    moved_count += 1
                    # --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Сообщаем UI, что файл надо убрать из коробки ---
                    # Примечание: для этого нужно будет доработать систему, чтобы знать,
                    # в какой "коробке" был файл. Пока это заглушка.
                    # self.file_restored_to_desktop.emit(category, str(dest))
                    self.logger.info(f"Файл '{src.name}' возвращен на рабочий стол.")
                else:
                    self.logger.warning(f"Файл для отмены перемещения не найден: {src}")
            except Exception as e:
                self.logger.warning(f"Не удалось отменить перемещение для {file_info['new']}: {e}")
        self.logger.info(f"Возвращено на место {moved_count} файлов.")

--- Файл: core/updater.py ---

# core/updater.py
import logging
import requests
from PyQt5.QtCore import QObject, pyqtSignal


class Updater(QObject):
    # Сигналы для отправки результатов в основной поток GUI
    # (новая_версия, ссылка_на_скачивание)
    update_available = pyqtSignal(str, str)
    up_to_date = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(self, current_version, github_repo):
        super().__init__()
        self.logger = logging.getLogger(__name__)
        self.current_version = current_version
        # Формируем URL для API GitHub
        self.api_url = f"https://api.github.com/repos/{github_repo}/releases/latest"

    def check_for_updates(self):
        """
        Выполняет проверку обновлений. Этот метод предназначен для запуска в отдельном потоке.
        """
        self.logger.info(f"Проверка обновлений по адресу: {self.api_url}")
        try:
            response = requests.get(self.api_url, timeout=10)
            # Проверяем, что запрос успешен (код 200)
            response.raise_for_status()

            data = response.json()
            latest_version = data['tag_name'].lstrip('v')  # Убираем 'v' из 'v1.1.0'
            download_url = data['html_url']

            self.logger.info(f"Текущая версия: {self.current_version}, Последняя версия на GitHub: {latest_version}")

            # Сравниваем версии. Для простоты сравниваем как строки.
            # Для сложных версий (1.10.0 vs 1.9.0) лучше использовать библиотеку 'semver'.
            if latest_version > self.current_version:
                self.update_available.emit(latest_version, download_url)
            else:
                self.up_to_date.emit("У вас установлена последняя версия.")

        except requests.exceptions.RequestException as e:
            self.logger.error(f"Ошибка сети при проверке обновлений: {e}")
            self.error.emit("Ошибка сети. Не удалось проверить обновления.")
        except KeyError:
            self.logger.error("Ошибка парсинга ответа от GitHub. Возможно, нет релизов.")
            self.error.emit("Не удалось получить информацию о версии с GitHub.")
        except Exception as e:
            self.logger.error(f"Неизвестная ошибка при проверке обновлений: {e}")
            self.error.emit("Произошла неизвестная ошибка.")

--- Файл: core/utils.py ---

# core/utils.py
import os
import json
import logging
from pathlib import Path

# --- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ ---
# Мы будем использовать pywin32 для надежного определения пути к рабочему столу
try:
    from win32com.shell import shell, shellcon
    PYWIN32_AVAILABLE = True
except ImportError:
    PYWIN32_AVAILABLE = False
# --- КОНЕЦ ИСПРАВЛЕНИЯ ---


# Определяем путь к конфигу относительно папки проекта
CONFIG_PATH = Path(__file__).resolve().parent.parent / "config.json"

def setup_logging():
    """Настройка системы логирования."""
    log_dir = Path(__file__).resolve().parent.parent / "logs"
    log_dir.mkdir(exist_ok=True)
    log_file = log_dir / "app_logs.txt"

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)-15s - %(levelname)-8s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler() # Вывод в консоль для отладки
        ]
    )
    # Отключаем слишком "шумные" логгеры
    logging.getLogger("apscheduler.scheduler").setLevel(logging.WARNING)
    return logging.getLogger(__name__)

logger = setup_logging()

def load_config() -> dict:
    """Загрузка конфигурации приложения."""
    default_config = {
        "language": "ru",
        "auto_organize": True,
        "run_initial_organization": True,
        "categories": {
            "Программы": [".exe", ".lnk", ".msi", ".bat"],
            "Документы": [".doc", ".docx", ".pdf", ".xls", ".xlsx", ".ppt", ".pptx", ".txt"],
            "Изображения": [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg"],
            "Медиа": [".mp3", ".mp4", ".avi", ".mkv", ".mov", ".wav"],
            "Архивы": [".zip", ".rar", ".7z", ".tar", ".gz"],
            "Код": [".py", ".js", ".html", ".css", ".java", ".cpp", ".cs"],
            "Другое": []
        },
        "exceptions": [],
        "sort_options": {"by_type": True, "by_name": False, "by_date": False, "by_size": False},
        "clean_options": {"remove_broken_shortcuts": True, "remove_temp_files": True, "remove_by_ext": True},
        "security": {"use_recycle_bin": True, "backup_before_operations": True}
    }

    if not CONFIG_PATH.exists():
        logger.info("Файл конфигурации не найден. Создается новый config.json со значениями по умолчанию.")
        save_config(default_config)
        return default_config

    try:
        with open(CONFIG_PATH, "r", encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        logger.error(f"Ошибка загрузки config.json: {e}. Будут использованы значения по умолчанию.")
        return default_config

def save_config(config: dict) -> None:
    """Сохранение конфигурации."""
    try:
        with open(CONFIG_PATH, "w", encoding='utf-8') as f:
            json.dump(config, f, indent=4, ensure_ascii=False)
        logger.info("Конфигурация успешно сохранена.")
    except IOError as e:
        logger.error(f"Ошибка сохранения конфигурации: {e}")

# --- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ ---
def get_desktop_path() -> str:
    """
    Надежно возвращает путь к рабочему столу текущего пользователя,
    независимо от языка системы.
    """
    if PYWIN32_AVAILABLE:
        try:
            # Спрашиваем у Windows, где находится рабочий стол
            path = shell.SHGetFolderPath(0, shellcon.CSIDL_DESKTOP, None, 0)
            logger.info(f"Обнаружен рабочий стол через pywin32: {path}")
            return path
        except Exception as e:
            logger.warning(f"Не удалось получить путь через pywin32: {e}. Используется запасной метод.")

    # Запасной метод, если pywin32 не сработал
    path = os.path.join(os.environ.get('USERPROFILE', ''), 'Desktop')
    logger.info(f"Используется запасной метод для определения рабочего стола: {path}")
    return path

def get_all_desktop_paths() -> list:
    """
    Возвращает список, содержащий путь к рабочему столу текущего пользователя.
    """
    desktop_path = get_desktop_path()
    if os.path.isdir(desktop_path):
        return [desktop_path]
    return []

--- Файл: core/watcher.py ---

# core/watcher.py
import time
import logging
from PyQt5.QtCore import QThread
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


class DesktopHandler(FileSystemEventHandler):
    """
    Обработчик событий файловой системы.
    Когда watchdog замечает событие, он передает его сюда.
    """

    def __init__(self, organizer):
        super().__init__()
        self.organizer = organizer
        self.logger = logging.getLogger(__name__)
        # Защита от дублирующихся событий, которые иногда генерирует ОС
        self.last_event_time = 0
        self.last_event_path = ""

    def on_created(self, event):
        """Вызывается, когда в отслеживаемой папке создается новый файл или папка."""
        try:
            # Нас интересуют только файлы
            if not event.is_directory:
                current_time = time.time()
                if (current_time - self.last_event_time < 1) and (event.src_path == self.last_event_path):
                    return  # Игнорируем дублирующееся событие

                self.last_event_time = current_time
                self.last_event_path = event.src_path

                # Даем файлу время на завершение записи (например, при скачивании)
                time.sleep(1)

                self.logger.info(f"Наблюдатель обнаружил новый файл: {event.src_path}")
                # Передаем файл на обработку в органайзер
                self.organizer.handle_new_file(event.src_path)
        except Exception as e:
            self.logger.error(f"Ошибка в обработчике файловых событий: {e}", exc_info=True)


class DesktopWatcher(QThread):
    """
    Наблюдатель, работающий в отдельном потоке, чтобы не блокировать основной интерфейс.
    """

    def __init__(self, organizer, path_to_watch):
        super().__init__()
        self.organizer = organizer
        self.path_to_watch = path_to_watch
        self.logger = logging.getLogger(__name__)
        self.observer = Observer()
        self._is_running = True

    def run(self):
        """Этот метод выполняется при запуске потока (`.start()`)."""
        event_handler = DesktopHandler(self.organizer)
        self.observer.schedule(event_handler, self.path_to_watch, recursive=False)
        self.observer.start()
        self.logger.info(f"Наблюдение за папкой '{self.path_to_watch}' запущено.")

        try:
            while self._is_running:
                time.sleep(1)
        except Exception as e:
            self.logger.error(f"Ошибка в потоке наблюдателя: {e}")
        finally:
            self.observer.stop()
            self.observer.join()
            self.logger.info("Наблюдение остановлено.")

    def stop(self):
        """Сигнализирует потоку о необходимости завершения."""
        self._is_running = False

--- Файл: logs.txt ---



--- Файл: main.py ---

# main.py
import sys
import os
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QApplication, QStyleFactory
from PyQt5.QtCore import Qt

# ... (блок для исправления пути PyInstaller остается без изменений) ...

from ui.main_window import MainWindow
from core.utils import setup_logging, load_config
# --- НОВЫЙ ИМПОРТ ---
from core.box_manager import BoxManager

try:
    import resources_rc
except ImportError:
    print("Внимание: файл ресурсов 'resources_rc.py' не найден.")
    pass

def main():
    os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "1"
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)

    setup_logging()
    config = load_config()

    app = QApplication(sys.argv)
    app.setStyle(QStyleFactory.create('Fusion'))

    theme = config.get("theme", "light")
    qss_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "ui", "styles", f"{theme}.qss")
    if os.path.exists(qss_file):
        with open(qss_file, "r", encoding="utf-8") as f:
            app.setStyleSheet(f.read())

    app.setWindowIcon(QIcon(":/icons/app_icon.ico"))

    # --- ИНТЕГРАЦИЯ СИСТЕМЫ "КОРОБОК" ---
    # 1. Создаем менеджер "коробок"
    box_manager = BoxManager(config)

    # 2. Создаем главное окно и передаем в него менеджер
    window = MainWindow(config, box_manager)
    window.show()

    # 3. Создаем все "коробки" после того, как основное приложение готово
    box_manager.create_all_boxes()

    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

--- Файл: requirements.txt ---

A P S c h e d u l e r = = 3 . 1 0 . 4 
 
 c e r t i f i = = 2 0 2 5 . 8 . 3 
 
 c h a r s e t - n o r m a l i z e r = = 3 . 4 . 3 
 
 i d n a = = 3 . 1 0 
 
 P y Q t 5 = = 5 . 1 5 . 1 1 
 
 P y Q t 5 - Q t 5 = = 5 . 1 5 . 2 
 
 P y Q t 5 _ s i p = = 1 2 . 1 7 . 0 
 
 p y t z = = 2 0 2 5 . 2 
 
 p y w i n 3 2 = = 3 0 6 
 
 r e q u e s t s = = 2 . 3 2 . 5 
 
 s i x = = 1 . 1 7 . 0 
 
 t z d a t a = = 2 0 2 5 . 2 
 
 t z l o c a l = = 5 . 3 . 1 
 
 u r l l i b 3 = = 2 . 5 . 0 
 
 w a t c h d o g = = 4 . 0 . 1 
 
 

